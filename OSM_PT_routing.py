# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OSMroutingPT
                                 A QGIS plugin
 It create the Public Transports path for each PT with a CSV table with stops sequence and coordinate
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-05
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Luigi Dal B./FlowRide
        email                : luigi.dalbosco@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.gui import QgsMapCanvas
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QListWidgetItem
from qgis.core import (QgsProperty, 
                       QgsVectorLayer, 
                       QgsField, 
                       QgsProject, 
                       edit, 
                       QgsExpression, 
                       QgsExpressionContext, 
                       QgsExpressionContextUtils,
                       QgsCoordinateReferenceSystem, 
                       QgsVectorFileWriter, 
                       QgsProcessingFeatureSourceDefinition,
                       QgsFeatureRequest,
                       QgsRectangle,
                       QgsPointXY,
)
from qgis import processing
import os.path
import pandas as pd
from PyQt5.QtWidgets import QMessageBox

# Initialize Qt resources from file resources.py
from .resources import *

# import functions from core_function.py
from .core_function import (create_minitrips, 
                            mini_routing, 
                            trips, 
                            save_and_stop_editing_layers,
                            if_remove
)

# Import the code for the dialog
from .OSM_PT_routing_dialog import OSMroutingPTDialog
import os.path

class OSMroutingPT:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        self.OSMPTrouting_dialog = OSMroutingPTDialog()

        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'OSMroutingPT_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Routing OSM Public Transport')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('OSMroutingPT', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/OSM_PT_routing/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'2. Routing OSM Public Transports'),
            callback=self.run,
            parent=self.iface.mainWindow())

        self.OSMPTrouting_dialog.updateNomRDstopsButton.clicked.connect(self.__updateStopsnmRD)

        self.OSMPTrouting_dialog.ZoomStopButton.clicked.connect(self.__ZoomStop)

        self.open_python_console()
        # will be set False in run()
        self.first_start = True
    
    def open_python_console(self):
        """Open the Python console programmatically."""
        if not self.iface.actionShowPythonDialog().isChecked():
            self.iface.actionShowPythonDialog().trigger()

    def __updateStopsnmRD(self):
        all_layers = QgsProject.instance().mapLayers().values()
        save_and_stop_editing_layers(all_layers)

        self.OSMPTrouting_dialog.stopsnmRDlistWidget.clear()  # Clear existing items
        dwnldfld = self.OSMPTrouting_dialog.DownloadQgsFolderWidget.filePath()
        folder_OSM = 'OSM_data'
        road_temp_folder = os.path.join(dwnldfld,folder_OSM )

        temp_folder = 'zoom_nmRD'
        nmRD_temp_folder = os.path.join(dwnldfld,temp_folder )

        full_roads_name = 'full_city_roads'
        full_roads_gpgk = str(road_temp_folder)+'/'+str(full_roads_name)+'.gpkg'

        OSMallroad_name = 'OSMallroad'
        OSMallroad_gpkg = os.path.join(nmRD_temp_folder,str(OSMallroad_name)+'.gpkg')

        tram_rails_name = 'OSM_tram'
        tram_rails_gpgk = str(road_temp_folder)+'/'+str(tram_rails_name)+'.gpkg'

        OSM_Regtrain_name = 'OSM_Regtrain'
        OSM_Regtrain_gpkg = str(road_temp_folder)+'/'+str(OSM_Regtrain_name)+'.gpkg'

        OSM_funicular_name = 'OSM_funicular'
        OSM_funicular_gpkg = str(road_temp_folder)+'/'+str(OSM_funicular_name)+'.gpkg'

        if not os.path.exists(nmRD_temp_folder):
            os.mkdir(nmRD_temp_folder)

        if not os.path.exists(OSMallroad_gpkg):
            ls_roads= []
            if os.path.exists(full_roads_gpgk):
                ls_roads.append(full_roads_gpgk)
            if os.path.exists(tram_rails_gpgk):
                ls_roads.append(tram_rails_gpgk)
            if os.path.exists(OSM_Regtrain_gpkg):
                ls_roads.append(OSM_Regtrain_gpkg)
            if os.path.exists(OSM_funicular_gpkg):
                ls_roads.append(OSM_funicular_gpkg)
            params = {'LAYERS':ls_roads,
                'CRS':QgsCoordinateReferenceSystem('EPSG:4326'),
                'OUTPUT':OSMallroad_gpkg}
            processing.run("native:mergevectorlayers",params)

        tempfolder = 'temp/temp_OSM_forrouting'
        temp_OSM_for_routing = os.path.join (dwnldfld,tempfolder)

        allstops_name = 'ALLstops'
        allstops_gpkg = os.path.join(nmRD_temp_folder, str(allstops_name)+'.gpkg')
        allstops_csv = os.path.join(nmRD_temp_folder, str(allstops_name)+'.csv')

        nmRD_stops_name = 'nmRD_stops'
        nmRD_stops_csv= os.path.join(nmRD_temp_folder, str(nmRD_stops_name)+'.csv')

        ls_files = os.listdir(temp_OSM_for_routing)
        ls_to_check = [file for file in ls_files if ".gpkg" in file]
                    

        allstops_to_check = pd.DataFrame()
        for to_check in ls_to_check:
            to_check_name = to_check[:-5]
            to_check_gpkg = os.path.join(temp_OSM_for_routing,to_check)
            to_check_csv = os.path.join(nmRD_temp_folder,str(to_check_name)+'.csv')
            to_check_layer = QgsVectorLayer(to_check_gpkg,to_check_name,"ogr")
            ls_fields_name_to_remove = ['lon','lat']
            
            for field_name in ls_fields_name_to_remove:
                field_index = to_check_layer.fields().indexFromName(field_name)
                if field_index != -1:
                    to_check_layer.startEditing()
                    to_check_layer.deleteAttribute(field_index)
                    to_check_layer.commitChanges()
                else:
                    print(f"Field '{field_name}' not found.")
            
            pr = to_check_layer.dataProvider()
            pr.addAttributes([
                QgsField("lon", QVariant.Double),
                QgsField("lat", QVariant.Double)])
            to_check_layer.updateFields()
            to_check_layer.commitChanges()
            
            expression2 = QgsExpression('$x')
            expression3 = QgsExpression('$y')
            
            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(to_check_layer))
            
            with edit(to_check_layer):
                for f in to_check_layer.getFeatures():
                    context.setFeature(f)
                    f['lon'] = expression2.evaluate(context)
                    f['lat'] = expression3.evaluate(context)
                    to_check_layer.updateFeature(f)
            
            if_remove(to_check_csv)
            QgsVectorFileWriter.writeAsVectorFormat(to_check_layer,to_check_csv,"utf-8",driverName = "CSV")
            df_to_check = pd.read_csv(to_check_csv,dtype = {'trip':int,'pos':int,'stop_id':str})
            if not df_to_check.empty:
                allstops_to_check = pd.concat([allstops_to_check,df_to_check], ignore_index=True)

        allstops_to_check.to_csv(allstops_csv,index = False)

        allstops_path = r"file:///{}?crs={}&delimiter={}&xField={}&yField={}".format(allstops_csv,"epsg:4326", ",", "lon", "lat")
        allstops_layer = QgsVectorLayer(allstops_path,allstops_name,"delimitedtext")
            
        param = {'INPUT':allstops_layer,
            'REFERENCE':OSMallroad_gpkg,
            'DISTANCE': 0.0000001,
            'METHOD':0}
        processing.run("native:selectwithindistance", param)

        allstops_layer.invertSelection()

        QgsVectorFileWriter.writeAsVectorFormat(allstops_layer,nmRD_stops_csv,"utf-8",driverName = "CSV",onlySelected=True)

        to_check = pd.read_csv(nmRD_stops_csv,dtype = {'trip':int,'pos':int,'stop_id':str})

        if not to_check.empty:
            i_row = 0
            while i_row < len(to_check):
                to_check.loc[i_row,"seq_stpID"] = str(to_check.loc[i_row,"line_name"])+'_trip'+str(to_check.loc[i_row,"trip"])+'_pos'+str(to_check.loc[i_row,"pos"])
                i_row += 1
            
            ls_stop_to_display = to_check.seq_stpID.unique()

            for stop_to_disp in ls_stop_to_display:
                self.OSMPTrouting_dialog.stopsnmRDlistWidget.addItem(QListWidgetItem(str(stop_to_disp)))
            if_remove(nmRD_stops_csv)
            to_check.to_csv(nmRD_stops_csv)
        else:
            self.OSMPTrouting_dialog.stopsnmRDlistWidget.addItem(QListWidgetItem(str('All the stops are on one of the networks (roads\'one or rails\'one)')))
    
    def __ZoomStop(self):
        dwnldfld = self.OSMPTrouting_dialog.DownloadQgsFolderWidget.filePath()
        temp_folder = 'zoom_nmRD'
        nmRD_temp_folder = os.path.join(dwnldfld,temp_folder )
        nmRD_stops_name = 'nmRD_stops'
        
        nmRD_stops_csv= os.path.join(nmRD_temp_folder, str(nmRD_stops_name)+'.csv')

        to_check = pd.read_csv(nmRD_stops_csv,index_col='seq_stpID')
        selected_item = self.OSMPTrouting_dialog.stopsnmRDlistWidget.currentItem().text()
        print(selected_item)

        print (to_check.at[selected_item,'lat'])
        
        latitude = float(to_check.at[selected_item,'lat'])
        longitude = float(to_check.at[selected_item,'lon'])
        target_point = QgsPointXY(longitude, latitude)

        canvas = self.iface.mapCanvas()

        canvas.setCenter(target_point)

        canvas.zoomScale(50)

        canvas.refresh()

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Routing OSM Public Transport'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
       
       
        # show the dialog
        self.OSMPTrouting_dialog.show()
        # Run the dialog event loop
        result = self.OSMPTrouting_dialog.exec_()

        # load the downloads and output folders
        dwnldfld = self.OSMPTrouting_dialog.DownloadQgsFolderWidget.filePath()

        outputspath = self.OSMPTrouting_dialog.OutPutQgsFolderWidget.filePath()


        # See if OK was pressed
        if result:

            msg = QMessageBox()
            msg.setIcon(QMessageBox.Information)
            # setting message for Message Box
            msg.setText("The \'OSM PT routing\' is in progress wait until the message box is closed")
            # setting Message box window title
            msg.setWindowTitle("!! wait the next message \'OSM PT routing\' is in progress !!")
            msg.show()
            
            all_layers = QgsProject.instance().mapLayers().values()
            save_and_stop_editing_layers(all_layers)


            temp_folder = 'OSM_data'
            road_temp_folder = os.path.join(dwnldfld,temp_folder)

            full_roads_name = 'full_city_roads'
            full_roads_gpgk = str(road_temp_folder)+'/'+str(full_roads_name)+'.gpkg'

            tram_rails_name = 'OSM_tram'
            tram_rails_gpgk = str(road_temp_folder)+'/'+str(tram_rails_name)+'.gpkg'
            
            OSM_Regtrain_name = 'OSM_Regtrain'
            OSM_Regtrain_gpkg = str(road_temp_folder)+'/'+str(OSM_Regtrain_name)+'.gpkg'

            OSM_funicular_name = 'OSM_funicular'
            OSM_funicular_gpkg = str(road_temp_folder)+'/'+str(OSM_funicular_name)+'.gpkg'
            
            tempfolder = 'temp/temp_OSM_forrouting'
            temp_OSM_for_routing = os.path.join (dwnldfld,tempfolder)

            OSM4rout_name = 'OSM4routing'
            OSM4rout_gpkg = str(outputspath)+'/'+str(OSM4rout_name)+'.gpkg'
            OSM4rout_csv= str(outputspath)+'/'+str(OSM4rout_name)+'.csv'

            OSM4routing_name = 'OSM4routing_XYminiTrips'
            OSM4routing_csv = str(outputspath)+'/'+str(OSM4routing_name)+'.csv'

            lines_trips_csv =  str(dwnldfld)+'/lines_trips.csv'
            
            shapes_txt = os.path.join(dwnldfld,'shapes.txt')

            trnsprt_shapes = str(outputspath)+'/mini_shapes.gpkg'

            tempfolder = 'temp/mini-trips'
            temp_folder_minitrip = os.path.join (dwnldfld,tempfolder)

            tempfolder = 'temp/lines_trips'
            temp_folder_linestrip= os.path.join (dwnldfld,tempfolder)

            name_folder = 'shapes'
            shape_folder = os.path.join(outputspath,name_folder)

            trips_done_name = 'trips_done'
            trips_done_csv = str(temp_folder_linestrip)+'/'+str(trips_done_name)+'.csv'

            if not os.path.exists(shape_folder):
                os.makedirs(shape_folder)
            if not os.path.exists(temp_folder_minitrip):
                os.makedirs(temp_folder_minitrip)
            if not os.path.exists(temp_folder_linestrip):
                os.makedirs(temp_folder_linestrip)

            # loading the temporary tables and outpust of OSMtocheck Plugin

            ls_files = os.listdir(temp_OSM_for_routing)
            ls_to_do = [file for file in ls_files if ".gpkg" in file]
            
            #ls_gpkg_to_run = [file for file in ls_files if ".gpkg" in file]

            # strategy changed, in the mini_routing function 
            # if the path has been already calculated is not considered
            # # to avoid make twice the routing, because the process is time demanding 
            # if os.path.exists(trips_done_csv):
            #     gpkg_done_df = pd.read_csv(trips_done_csv)
            #     ls_gpkg_done = list(gpkg_done_df.lines_draw_gpkg.unique())
            #     ls_to_do = [gpkg for gpkg in ls_gpkg_to_run if not gpkg in ls_gpkg_done ] 
            # else:
            #     ls_to_do = ls_gpkg_to_run

            ls_gpkg_df = pd.DataFrame(ls_to_do).rename(columns={0:'lines_draw_gpkg'})
            #ls_gpkg_df = pd.DataFrame(ls_gpkg_to_run).rename(columns={0:'lines_draw_gpkg'})

            # if_remove(trips_done_csv)
            # ls_gpkg_df.to_csv(trips_done_csv,index=False)

            # merging the layer to route
            layers_to_route = []
            for to_do in ls_to_do:
                layers_to_route.append(str(temp_OSM_for_routing)+'/'+str(to_do)+'|layername='+str(to_do[:-5]))

            if_remove(OSM4rout_gpkg)
            params = {'LAYERS':layers_to_route,
                        'CRS':QgsCoordinateReferenceSystem('EPSG:4326'),
                        'OUTPUT':OSM4rout_gpkg}
            processing.run("native:mergevectorlayers",params)
            
            # recalculate the coordinates of the stop position changed
            OSM4rout_layer = QgsVectorLayer(OSM4rout_gpkg,OSM4rout_name,"ogr")
            ls_fields_name_to_remove = ['lon','lat']

            for field_name in ls_fields_name_to_remove:
                field_index = OSM4rout_layer.fields().indexFromName(field_name)
                
                if field_index != -1:
                    OSM4rout_layer.startEditing()
                    OSM4rout_layer.deleteAttribute(field_index)
                    OSM4rout_layer.commitChanges()
                else:
                    print(f"Field '{field_name}' not found.")
            
            pr = OSM4rout_layer.dataProvider()
            pr.addAttributes([
                            QgsField("lon", QVariant.Double),
                            QgsField("lat", QVariant.Double)])
            OSM4rout_layer.updateFields()
            
            expression2 = QgsExpression('$x')
            expression3 = QgsExpression('$y')

            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(OSM4rout_layer))

            with edit(OSM4rout_layer):
                for f in OSM4rout_layer.getFeatures():
                    context.setFeature(f)
                    f['lon'] = expression2.evaluate(context)
                    f['lat'] = expression3.evaluate(context)
                    OSM4rout_layer.updateFeature(f)
            OSM4rout_layer.commitChanges()

            if_remove(OSM4rout_csv)
            QgsVectorFileWriter.writeAsVectorFormat(OSM4rout_layer,OSM4rout_csv,"utf-8",driverName = "CSV")

            print('creating mini-trips table')
            # create mini trips
            create_minitrips(OSM4rout_csv,OSM4routing_csv, lines_trips_csv)

            print('Start routing from start to end for each mini-trip')
            # routing
            mini_routing(OSM4routing_csv,full_roads_gpgk, tram_rails_gpgk, OSM_Regtrain_gpkg, OSM_funicular_gpkg, temp_folder_minitrip, trnsprt_shapes)
            
            lines_trips = pd.read_csv(lines_trips_csv)
            print("now it makes one file for each trip, it will take shorter time")
            idx = 0
            while idx < len(lines_trips):
                trip = str(lines_trips.loc[idx,'line_trip'])
                
                trip_gpkg = str(outputspath)+'/'+ str(trip)+'.gpkg'
                trip_csv = str(outputspath)+'/'+ str(trip)+'.csv'
                lines_trips.loc[idx,'gpkg'] = trip_gpkg
                lines_trips.loc[idx,'csv'] = trip_csv
                if not os.path.exists(trip_gpkg):
                    print (str(trip)+'  is merging all its mini-trips')
                    trips(trnsprt_shapes,trip,trip_gpkg, trip_csv, temp_folder_minitrip)
                
                if not QgsProject.instance().mapLayersByName(str(trip)):
                    trip_layer = QgsVectorLayer(trip_gpkg,trip,"ogr")
                    QgsProject.instance().addMapLayer(trip_layer)
                idx +=1



            if_remove(trips_done_csv)
            ls_gpkg_df.to_csv(trips_done_csv,index=False)
            os.remove(lines_trips_csv)
            lines_trips.to_csv(lines_trips_csv, index=False)



            ls_files_output = os.listdir(outputspath)

            trip_done = [file for file in ls_files_output if '.gpkg' in file]
            ls_trips = [file[:-5] for file in trip_done]

            missing = lines_trips[~lines_trips.line_trip.isin(ls_trips)]

            if not missing.empty :
                i_row = 0
                while i_row < len(missing):
                    trip = missing.loc[i_row,'line_trip']
                    print (str(trip)+' is missing')
                    i_row +=1
            else:
                print ('All Trips are ready for tracing their shape!')
            
            msg.close()

            msg2 = QMessageBox()
            msg2.setIcon(QMessageBox.Information)
            msg2.setText("Check the path if they are right, \neventually you can change them, \nbefore running \'3. GTFS shapes Tracer\' plugin")
            msg2.setWindowTitle("Done !")
            msg2.exec_()